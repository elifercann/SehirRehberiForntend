{"ast":null,"code":"import { InputRule } from 'prosemirror-inputrules';\n\nconst isMarkActive = (state, type) => {\n  const {\n    from,\n    $from,\n    to,\n    empty\n  } = state.selection;\n\n  if (empty) {\n    return Boolean(type.isInSet(state.storedMarks || $from.marks()));\n  }\n\n  return state.doc.rangeHasMark(from, to, type);\n};\n\nconst findNodeType = (type, $from) => {\n  for (let i = $from.depth; i > 0; i -= 1) {\n    if ($from.node(i).type === type) {\n      return $from.node(i).type;\n    }\n  }\n\n  return null;\n};\n\nconst isNodeActive = (state, type, attrs = {}) => {\n  const {\n    selection\n  } = state;\n  const {\n    $from,\n    to\n  } = selection;\n  const node = findNodeType(type, $from);\n\n  if (!Object.entries(attrs).length || !node) {\n    return Boolean(node);\n  }\n\n  return to <= $from.end() && $from.parent.hasMarkup(type, attrs);\n};\n\nconst getSelectionMarks = state => {\n  let marks = [];\n  const {\n    selection,\n    storedMarks\n  } = state;\n  const {\n    from,\n    to,\n    empty,\n    $from\n  } = selection;\n\n  if (empty) {\n    marks = storedMarks || $from.marks();\n  } else {\n    state.doc.nodesBetween(from, to, node => {\n      marks = [...marks, ...node.marks];\n    });\n  }\n\n  return marks;\n};\n\nconst getSelectionNodes = state => {\n  const nodes = [];\n  const {\n    selection: {\n      from,\n      to\n    }\n  } = state;\n  state.doc.nodesBetween(from, to, node => {\n    nodes.push(node);\n  });\n  return nodes;\n}; // Ref: https://github.com/ProseMirror/prosemirror-commands/blob/master/src/commands.js\n\n\nconst markApplies = (doc, ranges, type) => {\n  for (const range of ranges) {\n    const {\n      $from,\n      $to\n    } = range;\n    let canApply = $from.depth === 0 ? doc.type.allowsMarkType(type) : false;\n    doc.nodesBetween($from.pos, $to.pos, node => {\n      if (canApply) {\n        return false;\n      }\n\n      canApply = node.inlineContent && node.type.allowsMarkType(type);\n      return true;\n    });\n\n    if (canApply) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\nconst markInputRule = (regexp, markType, attrs) => {\n  return new InputRule(regexp, (state, match, start, end) => {\n    const {\n      tr\n    } = state;\n    const from = start;\n    let to = end;\n\n    if (match[2]) {\n      const textStart = start + match[0].indexOf(match[2]);\n      const textEnd = textStart + match[2].length;\n\n      if (textEnd < end) {\n        tr.delete(textEnd, end);\n      }\n\n      if (textStart > start) {\n        tr.delete(start, textStart);\n      }\n\n      to = start + match[2].length;\n    }\n\n    return tr.addMark(from, to, markType.create(attrs));\n  });\n};\n\nconst canInsert = (state, nodeType) => {\n  const {\n    $from\n  } = state.selection;\n\n  for (let d = $from.depth; d >= 0; d -= 1) {\n    const index = $from.index(d);\n\n    if ($from.node(d).canReplaceWith(index, index, nodeType)) {\n      return true;\n    }\n  }\n\n  return false;\n};\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { canInsert, getSelectionMarks, getSelectionNodes, isMarkActive, isNodeActive, markApplies, markInputRule };","map":{"version":3,"names":["InputRule","isMarkActive","state","type","from","$from","to","empty","selection","Boolean","isInSet","storedMarks","marks","doc","rangeHasMark","findNodeType","i","depth","node","isNodeActive","attrs","Object","entries","length","end","parent","hasMarkup","getSelectionMarks","nodesBetween","getSelectionNodes","nodes","push","markApplies","ranges","range","$to","canApply","allowsMarkType","pos","inlineContent","markInputRule","regexp","markType","match","start","tr","textStart","indexOf","textEnd","delete","addMark","create","canInsert","nodeType","d","index","canReplaceWith"],"sources":["C:/Users/ercan/source/repos/sehir-rehberi-spa/node_modules/ngx-editor/fesm2020/ngx-editor-helpers.mjs"],"sourcesContent":["import { InputRule } from 'prosemirror-inputrules';\n\nconst isMarkActive = (state, type) => {\n    const { from, $from, to, empty } = state.selection;\n    if (empty) {\n        return Boolean(type.isInSet(state.storedMarks || $from.marks()));\n    }\n    return state.doc.rangeHasMark(from, to, type);\n};\n\nconst findNodeType = (type, $from) => {\n    for (let i = $from.depth; i > 0; i -= 1) {\n        if ($from.node(i).type === type) {\n            return $from.node(i).type;\n        }\n    }\n    return null;\n};\nconst isNodeActive = (state, type, attrs = {}) => {\n    const { selection } = state;\n    const { $from, to } = selection;\n    const node = findNodeType(type, $from);\n    if (!Object.entries(attrs).length || !node) {\n        return Boolean(node);\n    }\n    return to <= $from.end() && $from.parent.hasMarkup(type, attrs);\n};\n\nconst getSelectionMarks = (state) => {\n    let marks = [];\n    const { selection, storedMarks } = state;\n    const { from, to, empty, $from } = selection;\n    if (empty) {\n        marks = storedMarks || $from.marks();\n    }\n    else {\n        state.doc.nodesBetween(from, to, (node) => {\n            marks = [...marks, ...node.marks];\n        });\n    }\n    return marks;\n};\n\nconst getSelectionNodes = (state) => {\n    const nodes = [];\n    const { selection: { from, to } } = state;\n    state.doc.nodesBetween(from, to, (node) => {\n        nodes.push(node);\n    });\n    return nodes;\n};\n\n// Ref: https://github.com/ProseMirror/prosemirror-commands/blob/master/src/commands.js\nconst markApplies = (doc, ranges, type) => {\n    for (const range of ranges) {\n        const { $from, $to } = range;\n        let canApply = $from.depth === 0 ? doc.type.allowsMarkType(type) : false;\n        doc.nodesBetween($from.pos, $to.pos, (node) => {\n            if (canApply) {\n                return false;\n            }\n            canApply = node.inlineContent && node.type.allowsMarkType(type);\n            return true;\n        });\n        if (canApply) {\n            return true;\n        }\n    }\n    return false;\n};\n\nconst markInputRule = (regexp, markType, attrs) => {\n    return new InputRule(regexp, (state, match, start, end) => {\n        const { tr } = state;\n        const from = start;\n        let to = end;\n        if (match[2]) {\n            const textStart = start + match[0].indexOf(match[2]);\n            const textEnd = textStart + match[2].length;\n            if (textEnd < end) {\n                tr.delete(textEnd, end);\n            }\n            if (textStart > start) {\n                tr.delete(start, textStart);\n            }\n            to = start + match[2].length;\n        }\n        return tr.addMark(from, to, markType.create(attrs));\n    });\n};\n\nconst canInsert = (state, nodeType) => {\n    const { $from } = state.selection;\n    for (let d = $from.depth; d >= 0; d -= 1) {\n        const index = $from.index(d);\n        if ($from.node(d).canReplaceWith(index, index, nodeType)) {\n            return true;\n        }\n    }\n    return false;\n};\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { canInsert, getSelectionMarks, getSelectionNodes, isMarkActive, isNodeActive, markApplies, markInputRule };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}